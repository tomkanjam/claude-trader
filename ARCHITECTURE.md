# Claude Trader - Simplified Architecture
**For Open Source, Self-Contained Deployment**

**Version:** 2.0 (Python)
**Date:** 2025-10-26
**Target Deployment:** Fly.io (single container)

---

## Core Principle: Keep It Simple

- **No microservices** - Single Python process
- **No Redis/PostgreSQL** - DuckDB for structured data, files for code
- **No complex queues** - Simple in-memory scheduler with `schedule` library
- **No separate workers** - Run strategies sequentially or with limited concurrency
- **Self-contained** - Everything in one Docker container

---

## Tech Stack

| Component | Technology | Why |
|-----------|-----------|-----|
| Runtime | Python 3.11+ | Rich ecosystem, async support |
| Language | Python | Best for trading, data analysis, indicators |
| AI SDK | anthropic (Claude Agent SDK) | Official Python SDK |
| Database | DuckDB | Embedded, analytics-optimized, single file |
| Scheduler | schedule | Simple, Pythonic cron-like scheduler |
| Exchange APIs | ccxt | 100+ exchanges, unified API |
| Indicators | TA-Lib + pandas-ta | 150+ technical indicators |
| Data Analysis | pandas + numpy | Industry standard |
| Web Server | FastAPI (optional) | Modern, fast, type hints |
| Deployment | Docker → Fly.io | Single container, easy deployment |

---

## Directory Structure

```
claude-trader/
├── src/
│   ├── agents/
│   │   ├── strategy_builder.py      # Meta-agent that generates strategies
│   │   └── strategy_executor.py     # Runs generated strategies
│   ├── tools/
│   │   ├── market_data.py           # ccxt exchange integration
│   │   ├── indicators.py            # TA-Lib indicator tools
│   │   ├── blockchain.py            # Blockchain data tools
│   │   └── file_system.py           # Read/write strategy files
│   ├── scheduler/
│   │   └── cron_scheduler.py        # schedule library wrapper
│   ├── storage/
│   │   ├── duckdb_client.py         # DuckDB client wrapper
│   │   └── schema.sql               # Database schema
│   ├── api/
│   │   └── server.py                # Optional: FastAPI server
│   └── main.py                      # Main entry point
├── strategies/                      # Generated by Strategy Builder
│   └── {strategy-name}/
│       ├── config.json              # Strategy metadata
│       └── agents.json              # Sub-agent definitions
├── data/
│   └── claude_trader.duckdb         # All structured data
├── analysis/                        # Optional: markdown reports
│   └── {strategy-name}/
│       └── 2025-10-26-14-30.md
├── requirements.txt
├── Dockerfile
├── fly.toml
└── README.md
```

---

## Data Storage Strategy

### DuckDB (Structured Data)

**Single file:** `data/claude_trader.duckdb`

```sql
-- Strategies
CREATE TABLE strategies (
  id VARCHAR PRIMARY KEY,
  name VARCHAR NOT NULL,
  description TEXT,
  status VARCHAR DEFAULT 'active', -- 'active', 'paused', 'stopped'
  interval VARCHAR,                 -- '1m', '5m', '15m', '1h', '4h', '1d'
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  config JSON                       -- Full config as JSONB
);

-- Analysis Results (Time-Series)
CREATE TABLE analysis_results (
  id INTEGER PRIMARY KEY,
  strategy_id VARCHAR REFERENCES strategies(id),
  timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  signal VARCHAR,                   -- 'BUY', 'SELL', 'HOLD'
  confidence DECIMAL(5,2),
  reasoning TEXT,
  data JSON,                        -- Full sub-agent results
  execution_time_ms INTEGER
);

-- Execution Logs
CREATE TABLE executions (
  id INTEGER PRIMARY KEY,
  strategy_id VARCHAR REFERENCES strategies(id),
  started_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  completed_at TIMESTAMP,
  status VARCHAR,                   -- 'success', 'error', 'timeout'
  error_message TEXT,
  tokens_used INTEGER,
  cost_usd DECIMAL(10,4)
);

-- Create indexes for common queries
CREATE INDEX idx_analysis_strategy_time ON analysis_results(strategy_id, timestamp DESC);
CREATE INDEX idx_executions_strategy ON executions(strategy_id, started_at DESC);
```

### File System (Code & Configs)

```
strategies/btc-rsi-whale/
├── config.json              # Strategy metadata
└── agents.json              # Sub-agent definitions (AgentDefinition objects)
```

**Why JSON instead of Python files?**
- Store sub-agent prompts and tool definitions in JSON
- Load them dynamically at runtime
- No need to execute generated `.py` files (simpler, safer)

---

## Core Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                      Main Python Process                     │
│                                                              │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  Strategy Builder Agent (Layer 1)                      │ │
│  │  • Takes natural language input                        │ │
│  │  • Generates config.json + agents.json                 │ │
│  │  • Writes to /strategies/{name}/                       │ │
│  └────────────────────────────────────────────────────────┘ │
│                            ↓                                 │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  Scheduler (schedule library)                          │ │
│  │  • Reads active strategies from DuckDB                 │ │
│  │  • Triggers executions based on interval              │ │
│  │  • Simple in-memory lock to prevent overlaps          │ │
│  └────────────────────────────────────────────────────────┘ │
│                            ↓                                 │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  Strategy Executor (Layer 2)                           │ │
│  │  • Loads strategy config + agents.json                 │ │
│  │  • Calls query() with agents + mcp_servers            │ │
│  │  • Claude spawns sub-agents in parallel               │ │
│  │  • Returns synthesis result                           │ │
│  └────────────────────────────────────────────────────────┘ │
│                            ↓                                 │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  Storage Layer                                         │ │
│  │  • Write analysis to DuckDB                            │ │
│  │  • Optional: markdown file for human readability      │ │
│  └────────────────────────────────────────────────────────┘ │
│                                                              │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  Custom MCP Tools (Layer 3)                            │ │
│  │  • Market data (ccxt: 100+ exchanges)                  │ │
│  │  • Indicators (TA-Lib: 150+ indicators)                │ │
│  │  • Blockchain APIs (Etherscan, etc.)                   │ │
│  │  • File system (read/write strategies)                 │ │
│  └────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                            ↕
                    ┌───────────────┐
                    │  DuckDB File  │
                    │ (persistent)  │
                    └───────────────┘
```

---

## Component Details

### 1. Strategy Builder Agent

**File:** `src/agents/strategy_builder.py`

```python
from anthropic import query, tool, create_sdk_mcp_server
from src.storage.file_system import write_strategy_files
from src.storage.duckdb_client import db
import json

async def create_strategy(user_input: str) -> dict:
    """Generate a new trading strategy from natural language."""

    # Define file system tool for writing strategy files
    file_tools = create_sdk_mcp_server(
        name="files",
        version="1.0.0",
        tools=[
            tool(
                name="write_strategy",
                description="Write strategy configuration files",
                parameters={
                    "strategy_name": {"type": "string"},
                    "config": {"type": "object"},
                    "agents": {"type": "array"}
                },
                handler=async lambda args: await write_strategy_files(
                    args["strategy_name"],
                    args["config"],
                    args["agents"]
                )
            )
        ]
    )

    builder_prompt = f"""You are the Strategy Builder for Claude Trader.

User's trading idea: "{user_input}"

Your job:
1. Analyze the strategy requirements
2. Ask clarifying questions if needed (use /ask-user)
3. Design the strategy architecture:
   - What sub-agents are needed? (e.g., price monitor, RSI analyzer, whale tracker)
   - What data sources? (market data via ccxt, blockchain, news)
   - What indicators? (RSI, MACD, Bollinger Bands, etc.)
   - What's the signal synthesis logic?
4. Generate a strategy package:
   - config.json: name, description, interval, trading pair, synthesis logic
   - agents.json: Array of AgentDefinition objects

AgentDefinition format:
{{
  "description": "What this sub-agent does",
  "prompt": "Specialized instructions for the sub-agent",
  "tools": ["mcp__market__get_price", "mcp__indicators__calculate_rsi", ...],
  "model": "sonnet"
}}

Available tools:
- mcp__market__get_price: Get current price for any symbol
- mcp__market__get_ohlcv: Get historical candlestick data
- mcp__indicators__calculate_rsi: Calculate RSI indicator
- mcp__indicators__calculate_macd: Calculate MACD indicator
- mcp__indicators__detect_divergence: Detect price/RSI divergences
- mcp__blockchain__get_whale_activity: Monitor large wallet movements

Example sub-agent prompts:
- Price Monitor: "Use get_price to fetch BTC/USDT price. Return JSON: {{'price': float, 'timestamp': str}}"
- RSI Analyzer: "Use get_ohlcv and calculate_rsi. Return JSON: {{'rsi': float, 'overbought': bool, 'oversold': bool, 'trend': str}}"
- Divergence Detector: "Use detect_divergence tool. Return JSON: {{'divergence_type': 'bullish'|'bearish'|'none', 'strength': 0-100, 'confidence': 0-100}}"

After designing, use the write_strategy tool to save the files."""

    async for msg in query(
        prompt=builder_prompt,
        options={
            "mcp_servers": {"files": file_tools},
            "max_turns": 20
        }
    ):
        # Stream progress to user
        if msg.type == "text":
            print(msg.content)

        if msg.type == "result" and msg.subtype == "success":
            # Extract strategy info and save to DuckDB
            strategy_id = extract_strategy_id(msg.result)

            db.execute("""
                INSERT INTO strategies (id, name, description, interval, config)
                VALUES (?, ?, ?, ?, ?)
            """, [strategy_id, ...])

            return {"strategy_id": strategy_id, "status": "created"}
```

### 2. Strategy Executor

**File:** `src/agents/strategy_executor.py`

```python
from anthropic import query
from src.storage.file_system import load_strategy
from src.storage.duckdb_client import db
from src.tools.market_data import market_tools
from src.tools.indicators import indicator_tools
from src.tools.blockchain import blockchain_tools
import json
import time

async def execute_strategy(strategy_id: str) -> dict:
    """Execute a trading strategy and return analysis result."""

    start_time = time.time()

    try:
        # Load strategy configuration and agents
        strategy = load_strategy(strategy_id)
        config = strategy["config"]
        agents = strategy["agents"]

        # Build orchestrator prompt
        agent_list = "\n".join([f"   - /agent {name}" for name in agents.keys()])

        orchestrator_prompt = f"""You are the orchestrator for: {config['name']}

Strategy: {config['description']}
Trading Pair: {config['trading_pair']}

Steps:
1. Spawn these sub-agents (they run in parallel):
{agent_list}

2. Wait for all sub-agent results

3. Synthesize the results into a trading signal using this logic:
{config.get('synthesis_logic', 'Apply the strategy rules from the description')}

4. Return ONLY a JSON object:
{{
  "signal": "BUY" | "SELL" | "HOLD",
  "confidence": 0-100,
  "reasoning": "detailed explanation",
  "sub_agent_results": {{
    // Include all sub-agent outputs
  }}
}}"""

        # Execute strategy with Claude SDK
        result = None
        async for msg in query(
            prompt=orchestrator_prompt,
            options={
                "agents": agents,
                "mcp_servers": {
                    "market": market_tools,
                    "indicators": indicator_tools,
                    "blockchain": blockchain_tools
                },
                "max_turns": 10
            }
        ):
            if msg.type == "result" and msg.subtype == "success":
                result = json.loads(msg.result)

        execution_time = int((time.time() - start_time) * 1000)

        # Save analysis to DuckDB
        db.execute("""
            INSERT INTO analysis_results
            (strategy_id, signal, confidence, reasoning, data, execution_time_ms)
            VALUES (?, ?, ?, ?, ?, ?)
        """, [
            strategy_id,
            result["signal"],
            result["confidence"],
            result["reasoning"],
            json.dumps(result),
            execution_time
        ])

        # Log successful execution
        db.execute("""
            INSERT INTO executions (strategy_id, completed_at, status)
            VALUES (?, CURRENT_TIMESTAMP, 'success')
        """, [strategy_id])

        return result

    except Exception as error:
        # Log failed execution
        db.execute("""
            INSERT INTO executions (strategy_id, completed_at, status, error_message)
            VALUES (?, CURRENT_TIMESTAMP, 'error', ?)
        """, [strategy_id, str(error)])

        raise
```

### 3. Scheduler

**File:** `src/scheduler/cron_scheduler.py`

```python
import schedule
import time
from datetime import datetime
from src.storage.duckdb_client import db
from src.agents.strategy_executor import execute_strategy
import asyncio

# Simple in-memory lock to prevent overlapping executions
running_strategies = set()

def run_strategy(strategy_id: str):
    """Execute a single strategy if not already running."""
    if strategy_id in running_strategies:
        print(f"[{strategy_id}] Already running, skipping...")
        return

    running_strategies.add(strategy_id)

    try:
        print(f"[{datetime.now()}] Running {strategy_id}")
        result = asyncio.run(execute_strategy(strategy_id))
        print(f"[{strategy_id}] Signal: {result['signal']}, Confidence: {result['confidence']}%")
    except Exception as error:
        print(f"[{strategy_id}] Error: {error}")
    finally:
        running_strategies.remove(strategy_id)

def should_run_now(interval: str) -> bool:
    """Check if a strategy with given interval should run now."""
    now = datetime.now()
    minute = now.minute
    hour = now.hour

    intervals = {
        '1m': True,
        '5m': minute % 5 == 0,
        '15m': minute % 15 == 0,
        '1h': minute == 0,
        '4h': minute == 0 and hour % 4 == 0,
        '1d': minute == 0 and hour == 0
    }

    return intervals.get(interval, False)

def check_and_run_strategies():
    """Check all active strategies and run those that should execute now."""
    strategies = db.execute("""
        SELECT id, interval FROM strategies WHERE status = 'active'
    """).fetchall()

    for strategy_id, interval in strategies:
        if should_run_now(interval):
            run_strategy(strategy_id)

def start_scheduler():
    """Start the strategy scheduler."""
    # Run check_and_run_strategies every minute
    schedule.every(1).minutes.do(check_and_run_strategies)

    print("Scheduler started")

    # Run indefinitely
    while True:
        schedule.run_pending()
        time.sleep(1)
```

### 4. Custom MCP Tools - Market Data

**File:** `src/tools/market_data.py`

```python
from anthropic import tool, create_sdk_mcp_server
import ccxt
import pandas as pd

# Initialize exchange (can be configured per strategy)
exchange = ccxt.binance()

market_tools = create_sdk_mcp_server(
    name="market",
    version="1.0.0",
    tools=[
        tool(
            name="get_price",
            description="Get current cryptocurrency price",
            parameters={
                "symbol": {"type": "string", "description": "Trading pair (e.g., BTC/USDT)"},
                "exchange_name": {"type": "string", "default": "binance"}
            },
            handler=async lambda args: {
                "content": [{
                    "type": "text",
                    "text": json.dumps(await get_current_price(
                        args["symbol"],
                        args.get("exchange_name", "binance")
                    ), indent=2)
                }]
            }
        ),

        tool(
            name="get_ohlcv",
            description="Get historical OHLCV candlestick data",
            parameters={
                "symbol": {"type": "string", "description": "Trading pair (e.g., BTC/USDT)"},
                "timeframe": {"type": "string", "default": "1h", "description": "1m, 5m, 15m, 1h, 4h, 1d"},
                "limit": {"type": "integer", "default": 100, "description": "Number of candles"}
            },
            handler=async lambda args: {
                "content": [{
                    "type": "text",
                    "text": json.dumps(await get_ohlcv_data(
                        args["symbol"],
                        args.get("timeframe", "1h"),
                        args.get("limit", 100)
                    ), indent=2)
                }]
            }
        )
    ]
)

async def get_current_price(symbol: str, exchange_name: str = "binance") -> dict:
    """Fetch current price from exchange."""
    ex = getattr(ccxt, exchange_name)()
    ticker = ex.fetch_ticker(symbol)

    return {
        "symbol": symbol,
        "price": ticker['last'],
        "volume_24h": ticker['quoteVolume'],
        "change_24h_percent": ticker['percentage'],
        "timestamp": ticker['timestamp']
    }

async def get_ohlcv_data(symbol: str, timeframe: str = "1h", limit: int = 100) -> dict:
    """Fetch historical OHLCV data."""
    ohlcv = exchange.fetch_ohlcv(symbol, timeframe, limit=limit)

    # Convert to pandas DataFrame for easier analysis
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])

    return {
        "symbol": symbol,
        "timeframe": timeframe,
        "candles": df.to_dict('records')
    }
```

### 5. Custom MCP Tools - Technical Indicators

**File:** `src/tools/indicators.py`

```python
from anthropic import tool, create_sdk_mcp_server
import ccxt
import talib
import pandas as pd
import numpy as np

indicator_tools = create_sdk_mcp_server(
    name="indicators",
    version="1.0.0",
    tools=[
        tool(
            name="calculate_rsi",
            description="Calculate RSI (Relative Strength Index) indicator",
            parameters={
                "symbol": {"type": "string"},
                "period": {"type": "integer", "default": 14},
                "timeframe": {"type": "string", "default": "1h"}
            },
            handler=async lambda args: {
                "content": [{
                    "type": "text",
                    "text": json.dumps(await calculate_rsi_indicator(
                        args["symbol"],
                        args.get("period", 14),
                        args.get("timeframe", "1h")
                    ), indent=2)
                }]
            }
        ),

        tool(
            name="calculate_macd",
            description="Calculate MACD indicator",
            parameters={
                "symbol": {"type": "string"},
                "fast": {"type": "integer", "default": 12},
                "slow": {"type": "integer", "default": 26},
                "signal": {"type": "integer", "default": 9},
                "timeframe": {"type": "string", "default": "1h"}
            },
            handler=async lambda args: {
                "content": [{
                    "type": "text",
                    "text": json.dumps(await calculate_macd_indicator(
                        args["symbol"],
                        args.get("fast", 12),
                        args.get("slow", 26),
                        args.get("signal", 9),
                        args.get("timeframe", "1h")
                    ), indent=2)
                }]
            }
        ),

        tool(
            name="detect_divergence",
            description="Detect RSI divergences (bullish/bearish)",
            parameters={
                "symbol": {"type": "string"},
                "lookback": {"type": "integer", "default": 20},
                "timeframe": {"type": "string", "default": "4h"}
            },
            handler=async lambda args: {
                "content": [{
                    "type": "text",
                    "text": json.dumps(await detect_rsi_divergence(
                        args["symbol"],
                        args.get("lookback", 20),
                        args.get("timeframe", "4h")
                    ), indent=2)
                }]
            }
        )
    ]
)

async def calculate_rsi_indicator(symbol: str, period: int = 14, timeframe: str = "1h") -> dict:
    """Calculate RSI using TA-Lib."""
    exchange = ccxt.binance()
    ohlcv = exchange.fetch_ohlcv(symbol, timeframe, limit=100)
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])

    # Calculate RSI using TA-Lib (one line!)
    rsi = talib.RSI(df['close'].values, timeperiod=period)
    current_rsi = float(rsi[-1])

    return {
        "symbol": symbol,
        "rsi": round(current_rsi, 2),
        "period": period,
        "overbought": current_rsi > 70,
        "oversold": current_rsi < 30,
        "trend": "bullish" if current_rsi > 50 else "bearish",
        "timestamp": df['timestamp'].iloc[-1]
    }

async def calculate_macd_indicator(symbol: str, fast: int = 12, slow: int = 26, signal: int = 9, timeframe: str = "1h") -> dict:
    """Calculate MACD using TA-Lib."""
    exchange = ccxt.binance()
    ohlcv = exchange.fetch_ohlcv(symbol, timeframe, limit=100)
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])

    # Calculate MACD using TA-Lib
    macd, macd_signal, macd_hist = talib.MACD(
        df['close'].values,
        fastperiod=fast,
        slowperiod=slow,
        signalperiod=signal
    )

    return {
        "symbol": symbol,
        "macd": float(macd[-1]),
        "signal": float(macd_signal[-1]),
        "histogram": float(macd_hist[-1]),
        "crossover": "bullish" if macd[-1] > macd_signal[-1] else "bearish",
        "timestamp": df['timestamp'].iloc[-1]
    }

async def detect_rsi_divergence(symbol: str, lookback: int = 20, timeframe: str = "4h") -> dict:
    """Detect RSI divergences."""
    exchange = ccxt.binance()
    ohlcv = exchange.fetch_ohlcv(symbol, timeframe, limit=lookback * 2)
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])

    # Calculate RSI
    df['rsi'] = talib.RSI(df['close'], timeperiod=14)

    # Simple divergence detection
    recent = df.tail(lookback)

    # Bullish divergence: price makes lower low, RSI makes higher low
    price_lower_low = recent['close'].iloc[-1] < recent['close'].iloc[-5]
    rsi_higher_low = recent['rsi'].iloc[-1] > recent['rsi'].iloc[-5]

    # Bearish divergence: price makes higher high, RSI makes lower high
    price_higher_high = recent['close'].iloc[-1] > recent['close'].iloc[-5]
    rsi_lower_high = recent['rsi'].iloc[-1] < recent['rsi'].iloc[-5]

    if price_lower_low and rsi_higher_low:
        return {
            "divergence_type": "bullish",
            "strength": 75,
            "confidence": 80,
            "description": "Price making lower lows while RSI making higher lows"
        }
    elif price_higher_high and rsi_lower_high:
        return {
            "divergence_type": "bearish",
            "strength": 75,
            "confidence": 80,
            "description": "Price making higher highs while RSI making lower highs"
        }
    else:
        return {
            "divergence_type": "none",
            "strength": 0,
            "confidence": 50,
            "description": "No divergence detected"
        }
```

### 6. DuckDB Client

**File:** `src/storage/duckdb_client.py`

```python
import duckdb
from typing import Any, List, Optional

class DuckDBClient:
    """Simple DuckDB client wrapper."""

    def __init__(self, db_path: str = "./data/claude_trader.duckdb"):
        self.conn = duckdb.connect(db_path)
        self._init_schema()

    def _init_schema(self):
        """Initialize database schema."""
        with open("./src/storage/schema.sql", "r") as f:
            schema = f.read()
            self.conn.execute(schema)

    def execute(self, sql: str, params: Optional[List[Any]] = None) -> duckdb.DuckDBPyConnection:
        """Execute SQL query."""
        if params:
            return self.conn.execute(sql, params)
        return self.conn.execute(sql)

    def fetchall(self, sql: str, params: Optional[List[Any]] = None) -> List[tuple]:
        """Fetch all results."""
        result = self.execute(sql, params)
        return result.fetchall()

    def fetchone(self, sql: str, params: Optional[List[Any]] = None) -> Optional[tuple]:
        """Fetch one result."""
        result = self.execute(sql, params)
        return result.fetchone()

    def close(self):
        """Close connection."""
        self.conn.close()

# Global instance
db = DuckDBClient()
```

---

## Deployment: Fly.io

### Dockerfile

```dockerfile
FROM python:3.11-slim

WORKDIR /app

# Install system dependencies for TA-Lib
RUN apt-get update && apt-get install -y \
    build-essential \
    wget \
    && rm -rf /var/lib/apt/lists/*

# Install TA-Lib C library
RUN wget http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz && \
    tar -xzf ta-lib-0.4.0-src.tar.gz && \
    cd ta-lib/ && \
    ./configure --prefix=/usr && \
    make && \
    make install && \
    cd .. && \
    rm -rf ta-lib ta-lib-0.4.0-src.tar.gz

# Copy requirements and install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy source code
COPY . .

# Create necessary directories
RUN mkdir -p /app/data /app/strategies /app/analysis

# Expose port (optional, if running FastAPI)
EXPOSE 8000

# Start application
CMD ["python", "-m", "src.main"]
```

### requirements.txt

```txt
# Claude Agent SDK
anthropic>=0.8.0

# Database
duckdb>=0.9.0

# Exchange APIs
ccxt>=4.0.0

# Technical Analysis
TA-Lib>=0.4.28
pandas-ta>=0.3.14b

# Data Analysis
pandas>=2.0.0
numpy>=1.24.0

# Scheduler
schedule>=1.2.0

# Optional: Web API
fastapi>=0.104.0
uvicorn>=0.24.0

# Utilities
python-dotenv>=1.0.0
pydantic>=2.0.0
```

### fly.toml

```toml
app = "claude-trader"
primary_region = "sjc"

[build]
  dockerfile = "Dockerfile"

[[mounts]]
  source = "claude_trader_data"
  destination = "/app/data"

[[mounts]]
  source = "claude_trader_strategies"
  destination = "/app/strategies"

[env]
  PYTHONUNBUFFERED = "1"

[[services]]
  internal_port = 8000
  protocol = "tcp"

  [[services.ports]]
    port = 80
    handlers = ["http"]

  [[services.ports]]
    port = 443
    handlers = ["tls", "http"]
```

### Deploy Commands

```bash
# Create app
fly apps create claude-trader

# Create volumes
fly volumes create claude_trader_data --region sjc --size 10
fly volumes create claude_trader_strategies --region sjc --size 5

# Set secrets
fly secrets set ANTHROPIC_API_KEY=sk-...

# Deploy
fly deploy

# View logs
fly logs

# SSH into container
fly ssh console
```

---

## Main Entry Point

**File:** `src/main.py`

```python
import os
from dotenv import load_dotenv
from src.scheduler.cron_scheduler import start_scheduler
from src.storage.duckdb_client import db

def main():
    """Main entry point for Claude Trader."""

    # Load environment variables
    load_dotenv()

    # Verify API key
    if not os.getenv("ANTHROPIC_API_KEY"):
        raise ValueError("ANTHROPIC_API_KEY environment variable not set")

    print("=" * 60)
    print("Claude Trader - AI-Powered Trading Analysis")
    print("=" * 60)
    print()

    # Initialize database
    print("Initializing database...")
    db._init_schema()

    # Count active strategies
    result = db.fetchone("SELECT COUNT(*) FROM strategies WHERE status = 'active'")
    active_count = result[0] if result else 0
    print(f"Active strategies: {active_count}")
    print()

    # Start scheduler
    print("Starting scheduler...")
    start_scheduler()

if __name__ == "__main__":
    main()
```

---

## Next Steps

1. **Build MVP**
   - [ ] Set up project with Python + Claude SDK
   - [ ] Install dependencies (ccxt, TA-Lib, pandas, DuckDB)
   - [ ] Implement DuckDB client and schema
   - [ ] Create indicator MCP tools (RSI, MACD, divergence)
   - [ ] Build Strategy Builder agent
   - [ ] Implement Strategy Executor
   - [ ] Add scheduler

2. **Test**
   - [ ] Create a simple RSI strategy manually
   - [ ] Test Strategy Executor with real market data
   - [ ] Verify DuckDB storage
   - [ ] Test end-to-end flow

3. **Deploy**
   - [ ] Build Docker image
   - [ ] Deploy to Fly.io
   - [ ] Test with real API keys
   - [ ] Monitor costs and performance

4. **Enhance**
   - [ ] Add CLI interface (Click or Typer)
   - [ ] Build FastAPI web UI
   - [ ] Add more indicators (Bollinger Bands, Stochastic, etc.)
   - [ ] Implement backtesting with historical data
   - [ ] Add Jupyter notebook examples

---

## Advantages of Python Stack

### 1. Technical Indicators (HUGE WIN)
```python
# TA-Lib: 150+ indicators in one line
rsi = talib.RSI(prices, timeperiod=14)
macd, signal, hist = talib.MACD(prices)
upper, middle, lower = talib.BBANDS(prices)
```

### 2. Exchange Integration
```python
# ccxt: 100+ exchanges with unified API
exchange = ccxt.binance()
ticker = exchange.fetch_ticker('BTC/USDT')
ohlcv = exchange.fetch_ohlcv('BTC/USDT', '1h')
```

### 3. Data Analysis
```python
# pandas: Industry standard
df['returns'] = df['close'].pct_change()
df['volatility'] = df['returns'].rolling(30).std()
df['sma_20'] = df['close'].rolling(20).mean()
```

### 4. Strategy Builder Generates Better Code
Claude has more training data on Python trading code, resulting in better generated strategies.

### 5. Future Backtesting
Mature frameworks exist: Backtrader, Zipline, VectorBT

---

**Status:** Ready for implementation
**Complexity:** Low (self-contained, minimal dependencies)
**Estimated Dev Time:** 1-2 weeks for MVP with Python's rich ecosystem
