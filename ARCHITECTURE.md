# Claude Trader - Simplified Architecture
**For Open Source, Self-Contained Deployment**

**Version:** 1.0
**Date:** 2025-10-26
**Target Deployment:** Fly.io (single container)

---

## Core Principle: Keep It Simple

- **No microservices** - Single Node.js process
- **No Redis/PostgreSQL** - DuckDB for structured data, files for code
- **No complex queues** - Simple in-memory scheduler with node-cron
- **No separate workers** - Run strategies sequentially or with limited concurrency
- **Self-contained** - Everything in one Docker container

---

## Tech Stack

| Component | Technology | Why |
|-----------|-----------|-----|
| Runtime | Node.js 20+ | Async I/O, TypeScript support |
| Language | TypeScript | Type safety, SDK support |
| AI SDK | @anthropic-ai/claude-agent-sdk | Core agent capabilities |
| Database | DuckDB | Embedded, analytics-optimized, single file |
| Scheduler | node-cron | In-process, simple intervals |
| Web Server | Fastify (optional) | Lightweight API if needed |
| Code Execution | tsx | Runtime TypeScript execution |
| Deployment | Docker → Fly.io | Single container, easy deployment |

---

## Directory Structure

```
claude-trader/
├── src/
│   ├── agents/
│   │   ├── strategy-builder.ts      # Meta-agent that generates strategies
│   │   └── strategy-executor.ts     # Runs generated strategies
│   ├── tools/
│   │   ├── market-data.ts           # Binance/CoinGecko API tools
│   │   ├── blockchain.ts            # Blockchain data tools
│   │   └── file-system.ts           # Read/write strategy files
│   ├── scheduler/
│   │   ├── cron-scheduler.ts        # node-cron wrapper
│   │   └── execution-lock.ts        # Simple in-memory locking
│   ├── storage/
│   │   ├── duckdb.ts                # DuckDB client wrapper
│   │   └── schema.sql               # Database schema
│   ├── api/
│   │   └── server.ts                # Optional: REST API for UI
│   └── index.ts                     # Main entry point
├── strategies/                      # Generated by Strategy Builder
│   └── {strategy-name}/
│       ├── config.json              # Strategy metadata
│       ├── agents.json              # Sub-agent definitions
│       └── tools.ts                 # Custom tools (optional)
├── data/
│   └── claude-trader.duckdb         # All structured data
├── analysis/                        # Optional: markdown reports
│   └── {strategy-name}/
│       └── 2025-10-26-14-30.md
├── Dockerfile
├── fly.toml
└── package.json
```

---

## Data Storage Strategy

### DuckDB (Structured Data)

**Single file:** `data/claude-trader.duckdb`

```sql
-- Strategies
CREATE TABLE strategies (
  id VARCHAR PRIMARY KEY,
  name VARCHAR NOT NULL,
  description TEXT,
  status VARCHAR DEFAULT 'active', -- 'active', 'paused', 'stopped'
  interval VARCHAR,                 -- '1m', '5m', '15m', '1h', '4h', '1d'
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  config JSON                       -- Full config as JSONB
);

-- Analysis Results (Time-Series)
CREATE TABLE analysis_results (
  id INTEGER PRIMARY KEY,
  strategy_id VARCHAR REFERENCES strategies(id),
  timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  signal VARCHAR,                   -- 'BUY', 'SELL', 'HOLD'
  confidence DECIMAL(5,2),
  reasoning TEXT,
  data JSON,                        -- Full sub-agent results
  execution_time_ms INTEGER
);

-- Execution Logs
CREATE TABLE executions (
  id INTEGER PRIMARY KEY,
  strategy_id VARCHAR REFERENCES strategies(id),
  started_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  completed_at TIMESTAMP,
  status VARCHAR,                   -- 'success', 'error', 'timeout'
  error_message TEXT,
  tokens_used INTEGER,
  cost_usd DECIMAL(10,4)
);

-- Create indexes for common queries
CREATE INDEX idx_analysis_strategy_time ON analysis_results(strategy_id, timestamp DESC);
CREATE INDEX idx_executions_strategy ON executions(strategy_id, started_at DESC);
```

### File System (Code & Configs)

```
strategies/btc-rsi-whale/
├── config.json              # Strategy metadata
└── agents.json              # Sub-agent definitions (AgentDefinition[])
```

**Why not store generated TypeScript in files?**
- Store sub-agent prompts and tool definitions in JSON
- Load them dynamically at runtime
- No need to execute generated `.ts` files (simpler, safer)

---

## Core Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                      Main Node.js Process                    │
│                                                              │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  Strategy Builder Agent (Layer 1)                      │ │
│  │  • Takes natural language input                        │ │
│  │  • Generates config.json + agents.json                 │ │
│  │  • Writes to /strategies/{name}/                       │ │
│  └────────────────────────────────────────────────────────┘ │
│                            ↓                                 │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  Scheduler (node-cron)                                 │ │
│  │  • Reads active strategies from DuckDB                 │ │
│  │  • Triggers executions based on interval              │ │
│  │  • Simple in-memory lock to prevent overlaps          │ │
│  └────────────────────────────────────────────────────────┘ │
│                            ↓                                 │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  Strategy Executor (Layer 2)                           │ │
│  │  • Loads strategy config + agents.json                 │ │
│  │  • Calls query() with agents + mcpServers             │ │
│  │  • Claude spawns sub-agents in parallel               │ │
│  │  • Returns synthesis result                           │ │
│  └────────────────────────────────────────────────────────┘ │
│                            ↓                                 │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  Storage Layer                                         │ │
│  │  • Write analysis to DuckDB                            │ │
│  │  • Optional: markdown file for human readability      │ │
│  └────────────────────────────────────────────────────────┘ │
│                                                              │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  Custom MCP Tools (Layer 3)                            │ │
│  │  • Market data (Binance, CoinGecko)                    │ │
│  │  • Blockchain APIs (Etherscan, etc.)                   │ │
│  │  • File system (read/write strategies)                 │ │
│  └────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                            ↕
                    ┌───────────────┐
                    │  DuckDB File  │
                    │ (persistent)  │
                    └───────────────┘
```

---

## Component Details

### 1. Strategy Builder Agent

**File:** `src/agents/strategy-builder.ts`

```typescript
import { query, tool, createSdkMcpServer } from "@anthropic-ai/claude-agent-sdk";
import { writeStrategyFiles } from "../storage/file-system";
import { db } from "../storage/duckdb";

export async function createStrategy(userInput: string) {
  const fileTools = createSdkMcpServer({
    name: "files",
    version: "1.0.0",
    tools: [
      tool("write_strategy", "Write strategy files", {
        strategyName: z.string(),
        config: z.object({}),
        agents: z.array(z.object({}))
      }, async (args) => {
        await writeStrategyFiles(args.strategyName, args.config, args.agents);
        return { content: [{ type: "text", text: "Strategy files written" }] };
      })
    ]
  });

  const builderPrompt = `You are the Strategy Builder for Claude Trader.

User's trading idea: "${userInput}"

Your job:
1. Analyze the strategy requirements
2. Ask clarifying questions if needed (use /ask-user)
3. Design the strategy architecture:
   - What sub-agents are needed? (e.g., price monitor, RSI analyzer, whale tracker)
   - What data sources? (market data, blockchain, news)
   - What's the signal synthesis logic?
4. Generate a strategy package:
   - config.json: name, description, interval, trading pair
   - agents.json: Array of AgentDefinition objects

AgentDefinition format:
{
  "description": "What this sub-agent does",
  "prompt": "Specialized instructions for the sub-agent",
  "tools": ["mcp__market__get_price", ...],
  "model": "sonnet"
}

Example sub-agent prompts:
- Price Monitor: "Fetch BTC price from Binance. Return JSON: {price: number, timestamp: string}"
- RSI Analyzer: "Calculate RSI(14). Return JSON: {rsi: number, overbought: boolean, oversold: boolean}"
- Whale Tracker: "Check top 50 BTC wallets. Return JSON: {accumulation_score: 0-100, confidence: 0-100}"

After designing, use the write_strategy tool to save the files.`;

  for await (const msg of query({
    prompt: builderPrompt,
    options: {
      mcpServers: { files: fileTools },
      maxTurns: 20
    }
  })) {
    // Stream progress to user
    if (msg.type === "text") {
      console.log(msg.content);
    }

    if (msg.type === "result" && msg.subtype === "success") {
      const strategyId = extractStrategyId(msg.result);

      // Save to DuckDB
      await db.run(`
        INSERT INTO strategies (id, name, description, interval, config)
        VALUES (?, ?, ?, ?, ?)
      `, [strategyId, ...]);

      return { strategyId, status: "created" };
    }
  }
}
```

### 2. Strategy Executor

**File:** `src/agents/strategy-executor.ts`

```typescript
import { query } from "@anthropic-ai/claude-agent-sdk";
import { loadStrategy } from "../storage/file-system";
import { db } from "../storage/duckdb";
import { marketTools, blockchainTools } from "../tools";

export async function executeStrategy(strategyId: string) {
  const startTime = Date.now();

  try {
    // Load strategy
    const strategy = await loadStrategy(strategyId);
    const { config, agents } = strategy;

    // Build orchestrator prompt
    const orchestratorPrompt = `You are the orchestrator for: ${config.name}

Strategy: ${config.description}

Steps:
1. Spawn these sub-agents (they run in parallel):
${Object.keys(agents).map(name => `   - /agent ${name}`).join('\n')}

2. Wait for all sub-agent results

3. Synthesize the results into a trading signal using this logic:
${config.synthesisLogic || "Apply the strategy rules from the description"}

4. Return ONLY a JSON object:
{
  "signal": "BUY" | "SELL" | "HOLD",
  "confidence": 0-100,
  "reasoning": "detailed explanation",
  "sub_agent_results": {
    // Include all sub-agent outputs
  }
}`;

    // Execute with Claude SDK
    let result;
    for await (const msg of query({
      prompt: orchestratorPrompt,
      options: {
        agents,
        mcpServers: {
          market: marketTools,
          blockchain: blockchainTools
        },
        maxTurns: 10
      }
    })) {
      if (msg.type === "result" && msg.subtype === "success") {
        result = JSON.parse(msg.result);
      }
    }

    const executionTime = Date.now() - startTime;

    // Save to DuckDB
    await db.run(`
      INSERT INTO analysis_results (strategy_id, signal, confidence, reasoning, data, execution_time_ms)
      VALUES (?, ?, ?, ?, ?, ?)
    `, [strategyId, result.signal, result.confidence, result.reasoning, JSON.stringify(result), executionTime]);

    await db.run(`
      INSERT INTO executions (strategy_id, completed_at, status)
      VALUES (?, CURRENT_TIMESTAMP, 'success')
    `, [strategyId]);

    return result;

  } catch (error) {
    await db.run(`
      INSERT INTO executions (strategy_id, completed_at, status, error_message)
      VALUES (?, CURRENT_TIMESTAMP, 'error', ?)
    `, [strategyId, error.message]);

    throw error;
  }
}
```

### 3. Scheduler

**File:** `src/scheduler/cron-scheduler.ts`

```typescript
import cron from "node-cron";
import { db } from "../storage/duckdb";
import { executeStrategy } from "../agents/strategy-executor";

const runningStrategies = new Set<string>(); // Simple in-memory lock

export function startScheduler() {
  // Check every minute for strategies that need to run
  cron.schedule('* * * * *', async () => {
    const now = new Date();

    // Get active strategies
    const strategies = await db.all(`
      SELECT id, interval FROM strategies WHERE status = 'active'
    `);

    for (const strategy of strategies) {
      if (shouldRun(strategy.interval, now) && !runningStrategies.has(strategy.id)) {
        runningStrategies.add(strategy.id);

        // Run async, don't block
        executeStrategy(strategy.id)
          .then(result => {
            console.log(`[${strategy.id}] Signal: ${result.signal}`);
          })
          .catch(error => {
            console.error(`[${strategy.id}] Error:`, error);
          })
          .finally(() => {
            runningStrategies.delete(strategy.id);
          });
      }
    }
  });

  console.log("Scheduler started");
}

function shouldRun(interval: string, now: Date): boolean {
  const minute = now.getMinutes();
  const hour = now.getHours();

  switch (interval) {
    case '1m': return true;
    case '5m': return minute % 5 === 0;
    case '15m': return minute % 15 === 0;
    case '1h': return minute === 0;
    case '4h': return minute === 0 && hour % 4 === 0;
    case '1d': return minute === 0 && hour === 0;
    default: return false;
  }
}
```

### 4. Custom MCP Tools

**File:** `src/tools/market-data.ts`

```typescript
import { tool, createSdkMcpServer } from "@anthropic-ai/claude-agent-sdk";
import { z } from "zod";

export const marketTools = createSdkMcpServer({
  name: "market",
  version: "1.0.0",
  tools: [
    tool(
      "get_price",
      "Get cryptocurrency price",
      {
        symbol: z.string().describe("Trading pair (e.g., BTCUSDT)"),
        exchange: z.enum(["binance", "coinbase"]).default("binance")
      },
      async (args) => {
        const url = args.exchange === "binance"
          ? `https://api.binance.com/api/v3/ticker/price?symbol=${args.symbol}`
          : `https://api.coinbase.com/v2/prices/${args.symbol}/spot`;

        const res = await fetch(url);
        const data = await res.json();

        return {
          content: [{ type: "text", text: JSON.stringify(data, null, 2) }]
        };
      }
    ),

    tool(
      "get_historical_prices",
      "Get historical price data",
      {
        symbol: z.string(),
        interval: z.enum(["1m", "5m", "15m", "1h", "4h", "1d"]),
        limit: z.number().default(100).describe("Number of candles")
      },
      async (args) => {
        const url = `https://api.binance.com/api/v3/klines?symbol=${args.symbol}&interval=${args.interval}&limit=${args.limit}`;
        const res = await fetch(url);
        const data = await res.json();

        // Parse kline data
        const candles = data.map((k: any) => ({
          time: k[0],
          open: parseFloat(k[1]),
          high: parseFloat(k[2]),
          low: parseFloat(k[3]),
          close: parseFloat(k[4]),
          volume: parseFloat(k[5])
        }));

        return {
          content: [{ type: "text", text: JSON.stringify(candles, null, 2) }]
        };
      }
    ),

    tool(
      "calculate_rsi",
      "Calculate RSI indicator",
      {
        prices: z.array(z.number()).describe("Closing prices"),
        period: z.number().default(14)
      },
      async (args) => {
        const rsi = calculateRSI(args.prices, args.period);
        return {
          content: [{ type: "text", text: JSON.stringify({
            rsi: rsi.toFixed(2),
            overbought: rsi > 70,
            oversold: rsi < 30
          }, null, 2) }]
        };
      }
    )
  ]
});

function calculateRSI(prices: number[], period: number): number {
  // RSI calculation implementation
  const changes = prices.slice(1).map((p, i) => p - prices[i]);
  const gains = changes.map(c => c > 0 ? c : 0);
  const losses = changes.map(c => c < 0 ? -c : 0);

  const avgGain = gains.slice(-period).reduce((a, b) => a + b) / period;
  const avgLoss = losses.slice(-period).reduce((a, b) => a + b) / period;

  if (avgLoss === 0) return 100;
  const rs = avgGain / avgLoss;
  return 100 - (100 / (1 + rs));
}
```

### 5. DuckDB Client

**File:** `src/storage/duckdb.ts`

```typescript
import Database from "duckdb";
import path from "path";

class DuckDBClient {
  private db: Database.Database;
  private conn: Database.Connection;

  constructor(dbPath: string = "./data/claude-trader.duckdb") {
    this.db = new Database(dbPath);
    this.conn = this.db.connect();
  }

  async init() {
    // Load schema
    const schema = await fs.readFile("./src/storage/schema.sql", "utf-8");
    await this.run(schema);
  }

  async run(sql: string, params: any[] = []): Promise<void> {
    return new Promise((resolve, reject) => {
      this.conn.run(sql, ...params, (err) => {
        if (err) reject(err);
        else resolve();
      });
    });
  }

  async all<T>(sql: string, params: any[] = []): Promise<T[]> {
    return new Promise((resolve, reject) => {
      this.conn.all(sql, ...params, (err, rows) => {
        if (err) reject(err);
        else resolve(rows as T[]);
      });
    });
  }

  async get<T>(sql: string, params: any[] = []): Promise<T | null> {
    const rows = await this.all<T>(sql, params);
    return rows[0] || null;
  }

  close() {
    this.conn.close();
    this.db.close();
  }
}

export const db = new DuckDBClient();
```

---

## Deployment: Fly.io

### Dockerfile

```dockerfile
FROM node:20-alpine

WORKDIR /app

# Install dependencies
COPY package*.json ./
RUN npm ci --production

# Copy source
COPY . .

# Build TypeScript
RUN npm run build

# Create data directory
RUN mkdir -p /app/data /app/strategies /app/analysis

# Expose port (optional, if running web API)
EXPOSE 3000

# Start app
CMD ["node", "dist/index.js"]
```

### fly.toml

```toml
app = "claude-trader"
primary_region = "sjc"

[build]
  dockerfile = "Dockerfile"

[[mounts]]
  source = "claude_trader_data"
  destination = "/app/data"

[[mounts]]
  source = "claude_trader_strategies"
  destination = "/app/strategies"

[env]
  NODE_ENV = "production"

[[services]]
  internal_port = 3000
  protocol = "tcp"

  [[services.ports]]
    port = 80
    handlers = ["http"]

  [[services.ports]]
    port = 443
    handlers = ["tls", "http"]
```

### Deploy Commands

```bash
# Create app
fly apps create claude-trader

# Create volumes
fly volumes create claude_trader_data --region sjc --size 10
fly volumes create claude_trader_strategies --region sjc --size 5

# Set secrets
fly secrets set ANTHROPIC_API_KEY=sk-...

# Deploy
fly deploy

# View logs
fly logs

# SSH into container
fly ssh console
```

---

## Cost Optimization

### Prompt Caching

```typescript
// In strategy executor
const cachedContext = `
Strategy: ${config.name}
Trading Pair: ${config.tradingPair}
Interval: ${config.interval}

Sub-agents:
${JSON.stringify(agents, null, 2)}

Tools available:
- mcp__market__get_price
- mcp__market__get_historical_prices
- mcp__market__calculate_rsi
`;

for await (const msg of query({
  prompt: [
    { role: "system", content: cachedContext, cache_control: { type: "ephemeral" } },
    { role: "user", content: orchestratorPrompt }
  ],
  options: { /* ... */ }
})) {
  // Process...
}
```

### Rate Limiting

```typescript
// Simple in-memory rate limiter
const rateLimits = new Map<string, number[]>();

function checkRateLimit(apiName: string, maxPerMinute: number): boolean {
  const now = Date.now();
  const calls = rateLimits.get(apiName) || [];

  // Remove calls older than 1 minute
  const recent = calls.filter(t => now - t < 60000);

  if (recent.length >= maxPerMinute) {
    return false; // Rate limit exceeded
  }

  recent.push(now);
  rateLimits.set(apiName, recent);
  return true;
}
```

---

## Next Steps

1. **Build MVP**
   - [ ] Set up project with TypeScript + Claude SDK
   - [ ] Implement DuckDB client and schema
   - [ ] Create basic market data MCP tools
   - [ ] Build simple Strategy Builder agent
   - [ ] Implement Strategy Executor
   - [ ] Add node-cron scheduler

2. **Test**
   - [ ] Create a simple RSI strategy manually
   - [ ] Test Strategy Executor with mock data
   - [ ] Verify DuckDB storage
   - [ ] Test end-to-end flow

3. **Deploy**
   - [ ] Dockerize application
   - [ ] Deploy to Fly.io
   - [ ] Test with real API keys
   - [ ] Monitor costs and performance

4. **Enhance**
   - [ ] Add CLI interface
   - [ ] Build simple web UI (optional)
   - [ ] Add more data source tools
   - [ ] Implement backtesting mode

---

**Status:** Ready for implementation
**Complexity:** Low (self-contained, minimal dependencies)
**Estimated Dev Time:** 1-2 weeks for MVP
